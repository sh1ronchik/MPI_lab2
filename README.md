# Состав команды
Работу выполнили студенты группы **22ПИ1**:

| Участник | Вклад в проект |
|---------|----------------|
| **Овсянников Артём Сергеевич** | Реализовал задание **1**: вычисление множества Мандельброта с использованием OpenMP. |
| **Шейх Руслан Халедович** |  |

# Руководство по настройке OpenMP проекта

## 1. Установка (Ubuntu)
```bash
sudo apt update
sudo apt install -y build-essential gcc libomp-dev
```

## 2. Структура проекта
```
task1/
├── scripts/
│   └── task1.c
├── data/
│   └── result.csv        # Вывод в CSV
```

## 3. Компиляция
Task 1
```bash
gcc -fopenmp -O3 -std=c99 -Wall task1/scripts/task1.c -o task1/scripts/task1 -lm
```


## 4. Запуск
Task 1:
```bash
./task1/scripts/task1 <nthreads> <npoints>
```

Пример:
```bash
./task1/scripts/task1 4 1000000
```

## 5. Формат CSV
Task 1:
```
real,imaginary
```

Пример:
```csv
real,imaginary
-0.750000000000000,-0.100000000000000
-0.500000000000000,0.000000000000000
0.000000000000000,0.000000000000000
```

## 6. Используемые OpenMP функции и директивы

### 6.1. `omp_set_num_threads(int num_threads)`
**Назначение**: Устанавливает количество потоков для последующих параллельных регионов.

**Использование в проекте**:
```c
omp_set_num_threads(nthreads);
```
Задает количество потоков, передаваемое через аргумент командной строки.

---

### 6.2. `omp_get_wtime()`
**Назначение**: Возвращает время в секундах с некоторого момента в прошлом (wall-clock time).

**Использование в проекте**:
```c
double start_time = omp_get_wtime();
double end_time = omp_get_wtime();
double elapsed = end_time - start_time;
```
Используется для измерения времени выполнения параллельных вычислений.

---

### 6.3. `omp_get_thread_num()`
**Назначение**: Возвращает номер текущего потока (от 0 до num_threads-1).

**Использование в проекте**:
```c
fprintf(stderr, "Thread %d: malloc failed\n", omp_get_thread_num());
```
Используется для идентификации потока при выводе отладочной информации и сообщений об ошибках.

---

### 6.4. `#pragma omp parallel`
**Назначение**: Создает параллельный регион, в котором код выполняется несколькими потоками.

**Использование в проекте**:
```c
#pragma omp parallel
{
    // Этот блок выполняется всеми потоками параллельно
    // Каждый поток имеет свои локальные переменные
}
```
Создает параллельный регион для распределенного вычисления точек множества Мандельброта.

---

### 6.5. `#pragma omp for schedule(dynamic, chunk_size)`
**Назначение**: Распределяет итерации цикла между потоками.

**Параметры**:
- `schedule(dynamic, 100)` — динамическое распределение итераций порциями по 100 элементов

**Использование в проекте**:
```c
#pragma omp for schedule(dynamic, 100)
for (long long i = 0; i < grid_dim; i++) {
}
```

---

### 6.6. `#pragma omp critical`
**Назначение**: Определяет критическую секцию — блок кода, который может выполняться только одним потоком одновременно.

**Использование в проекте**:
```c
#pragma omp critical
{
    memcpy(&results[result_count], local_results, local_count * sizeof(MandelbrotPoint));
    result_count += local_count;
}
```

---